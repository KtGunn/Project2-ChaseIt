
#include "ros/ros.h"
#include "ball_chaser/DriveToTarget.h"
#include <sensor_msgs/Image.h>

// Client
ros::ServiceClient g_Client;

// Send drive commands to the drive_bot node
void drive_bot (float vel_x, float rate_z, const bool nodrive=true) {

    ROS_INFO_STREAM ("Driving to target ");

    ball_chaser::DriveToTarget srv;
    srv.request.linear_x = vel_x;    
    srv.request.angular_z = rate_z;

    // nodrive is used todebug the ball finding algorithm
    if (!nodrive && !g_Client.call (srv)) {
	ROS_ERROR ( "process_image failed to deliver svcReq to drive_bot!");
    }
    return;
}

static bool gMoving = false;

void image_callback (const sensor_msgs::Image image) {

    // Throttle the messaging to console
    static int throttle = 0;
    static int squawk = 20;

    // Value of pixel defining the ball we seek
    const static int white_pixel_value = 255;
    
    // State variables
    typedef enum {outofview=0, inview} enLooking;   // Ball is either 
						    // in view or not
    typedef enum {nowhite, white, done} enState;    // As image is
						    // scanned we see,
						    // then don't see
						    // white pixels
    typedef enum {seeking=0, chasing} enAction; // We're either
						// seeking or chasing
						// the ball
    static enAction action=seeking; // Start out seeking

    // Image variables
    uint height = image.height;
    uint width = image.width;
    uint step = image.step;
    uint channels = step/width; // RGB is three channels

    if (throttle >= squawk) {
	ROS_INFO ("\n Image! w%d x h%d / step%d size%d", width, height, step, height*step );
    }
    
    ///////////////////////////////////////////////////////////////////////////////////////
    /// IMAGE scanning section
    //
    int aVert[2] = {-1,-1};
    int aWide[2] = {1000,-1000};
    enLooking viewState = outofview;
    for (int row=0; row < height; row++) {

	enState state = nowhite;
	int aHor[2] = {-1,-1};

	for (int hor=0; hor < step ; hor += channels) {
	    switch (state) {
	    case nowhite :
		// Looking for the switch TO white
		if (image.data[row*step + hor] == white_pixel_value &&
		    image.data[row*step + hor +1] == white_pixel_value &&
		    image.data[row*step + hor +2] == white_pixel_value) {
		    
		    state = white;
		    aHor[0] = hor/3;
		}
		break;
	    case white :
		// Looking for the switch FROM white
		if (image.data[row*step + hor] != white_pixel_value &&
		    image.data[row*step + hor +1] != white_pixel_value &&
		    image.data[row*step + hor +2] != white_pixel_value) {

		    aHor[1] = (hor-3)/3;
		    state = done;
		} 
		break;
	    }
	    if (state == done) {
		break;
	    }
	}

	if (state == white) {
	    // We went over the right edge
	    aHor[1] = (step-3)/3;
	    state = done;
	}
	if (state == done) {

	    if (aWide[0] > aHor[0]) {
		aWide[0] = aHor[0];
	    }
	    if (aWide[1] < aHor[1]) {
		aWide[1] = aHor[1];
	    }
	}
	
	if (viewState == outofview) {
	    if (aHor[0] > -1) {
		aVert[0] = row;
		viewState = inview;
	    }
	} else if (viewState == inview) {
	    // If ball was in view but no more, we bail out
	    if (aHor[0] < 0) {
		aVert[1] = row-1;
		break;
	    }
	}
    }
    
    static char* aState[2] = {"out_of_view", "in_view"};
    if (throttle++ >= squawk) {
	ROS_INFO (" VertRange %d %d : %d :: %s", aVert[0], aVert[1], aVert[1]-aVert[0], aState[(int)viewState]);
	ROS_INFO ("  HorRange %d %d : %d", aWide[0], aWide[1], aWide[1]-aWide[0]);
	throttle = 0;
    }

    if ( viewstate == outof_view ) {
    }
    
    // STOPPED || Stopping
    if ( !blBallInView ) {
	if ( gMoving) {
	    drive_bot (0.0, 0.0);
	    gMoving = false;
	}
	return;
    }
    
    if ( white_pixel_column <= width/3 ) {
	// Drive left (+ rZ)
	drive_bot (0.15, 0.1);
    } else if ( white_pixel_column >= (2*width)/3 ) {
	// Drive right (- rZ)
	drive_bot (0.15, -0.1);
    } else {
	// Drive right straight ahead
	drive_bot (0.15, 0.0);
    }

    gMoving = true;
    
    return;
}

int main (int argc, char* argv[]) {

    // Boiler plate
    ros::init (argc, argv, "process_image");
    ros::NodeHandle handle;

    ROS_INFO ( " starting process_image ..." );

    // We'll be requesting moves
    g_Client = handle.serviceClient<ball_chaser::DriveToTarget>("/ball_chaser/command_robot");

    if (true) {
	// Wait for ROS start
	int start_time;
	while (not start_time) {
	    start_time = ros::Time::now().toSec() - start_time;
	}
    }

    // We'll subsrice to camera images
    int qsize = 10;
    ros::Subscriber sub = handle.subscribe ( "/camera/rgb/image_raw", qsize, image_callback);

    
    ROS_INFO (" ... process_image is in the loop! " );

    // Into the events loop
    ros::spin();

    return (0);
}

